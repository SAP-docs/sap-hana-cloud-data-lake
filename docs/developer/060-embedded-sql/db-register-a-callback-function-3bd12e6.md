<!-- loio3bd12e6c6c5f1014b9d2d85be55df0a4 -->

# db\_register\_a\_callback Function

Register a callback function.



```
void db_register_a_callback(
SQLCA * <sqlca>,
a_db_callback_index <index>,
( SQL_CALLBACK_PARM ) <callback> );
```



## Parameters

 sqlca
 :   A pointer to a SQLCA structure.

  index
 :   An index value identifying the type of callback described below.

  callback
 :   The address of a user-defined callback function.

 

## Remarks

This function registers callback functions.

If you do not register a DB\_CALLBACK\_WAIT callback, the default action is to do nothing. Your application blocks, waiting for the database response. You must register a callback for the MESSAGE TO CLIENT statement.

To remove a callback, pass a null pointer as the *<callback\>* function.

The following values are allowed for the *<index\>* parameter:

 DB\_CALLBACK\_DEBUG\_MESSAGE
 :   The supplied function is called once for each debug message and is passed a null-terminated string containing the text of the debug message. A debug message is a message that is logged to the LogFile file. In order for a debug message to be passed to this callback, the LogFile connection parameter must be used. The string normally has a newline character \(\\n\) immediately before the terminating null character. The prototype of the callback function is as follows:

    ```
    void SQL_CALLBACK <debug_message_callback>(
    SQLCA * <sqlca>,
    char * <message_string> );
    ```

  DB\_CALLBACK\_START
 :   The prototype is as follows:

    ```
    void SQL_CALLBACK <start_callback>( SQLCA * <sqlca> );
    ```

    This function is called just before a database request is sent to the server. DB\_CALLBACK\_START is used only on Windows.

  DB\_CALLBACK\_FINISH
 :   The prototype is as follows:

    ```
    void SQL_CALLBACK <finish_callback>( SQLCA * <sqlca> );
    ```

    This function is called after the response to a database request has been received by the DBLIB interface DLL. DB\_CALLBACK\_FINISH is used only on Windows operating systems.

  DB\_CALLBACK\_CONN\_DROPPED
 :   The prototype is as follows:

    ```
    void SQL_CALLBACK <conn_dropped_callback> (
    SQLCA * <sqlca>,
    char * <conn_name> );
    ```

    This function is called when the database server is about to drop a connection because of a liveness timeout, through a DROP CONNECTION statement, or because the database server is being shut down. The connection name *<conn\_name\>* is passed in to allow you to distinguish between connections. If the connection was not named, it has a value of NULL.

  DB\_CALLBACK\_WAIT
 :   The prototype is as follows:

    ```
    void SQL_CALLBACK <wait_callback>( SQLCA * <sqlca> );
    ```

    This function is called repeatedly by the interface library while the database server or client library is busy processing your database request.

  DB\_CALLBACK\_MESSAGE
 :   This is used to enable the application to handle messages received from the server during the processing of a request. Messages can be sent to the client application from the database server using the SQL MESSAGE statement. Messages can also be generated by long running database server statements.

    The callback prototype is as follows:

    ```
    void SQL_CALLBACK <message_callback>(
    SQLCA * <sqlca>,
    unsigned char <msg_type>,
    an_sql_code <code>,
    unsigned short <length>,
    char *  <msg>
    );
    ```

    The *<msg\_type\>* parameter states how important the message is. You can handle different message types in different ways. The following possible values for *<msg\_type\>* are defined in `sqldef.h`.

     MESSAGE\_TYPE\_INFO
     :   The message type was INFO.

      MESSAGE\_TYPE\_WARNING
     :   The message type was WARNING.

      MESSAGE\_TYPE\_ACTION
     :   The message type was ACTION.

      MESSAGE\_TYPE\_STATUS
     :   The message type was STATUS.

      MESSAGE\_TYPE\_PROGRESS
     :   The message type was PROGRESS. This type of message is generated by long running database server statements such as BACKUP DATABASE and LOAD TABLE.

     The *<code\>* parameter may provide a SQLCODE associated with the message, otherwise the value is 0.

    The *<length\>* parameter tells you how long the message is.

    The *<msg\>* parameter points to the message text. The message is *not* null-terminated.

    DBLIB, ODBC, and C API clients can use the DB\_CALLBACK\_MESSAGE callback to receive progress messages. For example, the Interactive SQL callback displays STATUS and INFO message on the *History* tab, while messages of type ACTION and WARNING go to a window. If an application does not register this callback, there is a default callback, which causes all messages to be written to the server logfile \(if debugging is on and a logfile is specified\). In addition, messages of type MESSAGE\_TYPE\_WARNING and MESSAGE\_TYPE\_ACTION are more prominently displayed, in an operating system-dependent manner.

    When a message callback is not registered by the application, messages sent to the client are saved to the message log file when the LogFile connection parameter is specified. Also, ACTION or STATUS messages sent to the client appear in a window on Windows operating systems and are logged to stderr on UNIX and Linux operating systems.

  DB\_CALLBACK\_VALIDATE\_FILE\_TRANSFER
 :   This is used to register a file transfer validation callback function. Before allowing any transfer to take place, the client library invokes the validation callback, if it exists. If the client data transfer is being requested during the execution of indirect statements such as from within a stored procedure, the client library will not allow a transfer unless the client application has registered a validation callback. The conditions under which a validation call is made are described more fully below.

    The callback prototype is as follows:

    ```
    int SQL_CALLBACK <file_transfer_callback>(
    SQLCA * <sqlca>,
    char * <file_name>,
    int <is_write>
    );
    ```

    The *<file\_name\>* parameter is the name of the file to be read or written. The *<is\_write\>* parameter is 0 if a read is requested \(transfer from the client to the server\), and non-zero for a write. The callback function should return 0 if the file transfer is not allowed, non-zero otherwise.

    For data security, the server tracks the origin of statements requesting a file transfer. The server determines if the statement was received directly from the client application. When initiating the transfer of data from the client, the server sends the information about the origin of the statement to the client software. On its part, the Embedded SQL client library allows unconditional transfer of data only if the data transfer is being requested due to the execution of a statement sent directly by the client application. Otherwise, the application must have registered the validation callback described above, in the absence of which the transfer is denied and the statement fails with an error. If the client statement invokes a stored procedure already existing in the database, then the execution of the stored procedure itself is considered not to have been for a client initiated statement. However, if the client application explicitly creates a temporary stored procedure then the execution of the stored procedure results in the server treating the procedure as having been client initiated. Similarly, if the client application executes a batch statement, then the execution of the batch statement is considered as being done directly by the client application.

 

The following is an example of a MESSAGE callback and how to register it.

```
#include <stdio.h>
#include <stdlib.h>
#include "sqldef.h"

EXEC SQL INCLUDE SQLCA;
EXEC SQL SET SQLCA "&sqlca";

void SQL_CALLBACK messages( SQLCA *sqlca, 
    unsigned char   msg_type, 
    an_sql_code     sqlcode, 
    unsigned short  length, 
    char *          msg )
{
    size_t  mlen;
    char    *mtype;
    char    mbuffer[80];

    switch( msg_type )
    {
        case MESSAGE_TYPE_INFO:
            mtype = "INFO";
            break;
        case MESSAGE_TYPE_WARNING:
            mtype = "WARNING";
            break;
        case MESSAGE_TYPE_ACTION:
            mtype = "ACTION";
            break;
        case MESSAGE_TYPE_STATUS:
            mtype = "STATUS";
            break;
        case MESSAGE_TYPE_PROGRESS:
            mtype = "PROGRESS";
            break;
    }
    mlen = __min( length, sizeof(mbuffer) );
    strncpy( mbuffer, msg, mlen );
    mbuffer[mlen] = '\0';
    printf( "Message was \"%s\", type %s, SQLCODE(%d)\n", mbuffer, mtype, sqlcode );
}

int main( int argc, char *argv[] )
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *sqlstr = "MESSAGE 'All is well' TYPE INFO TO CLIENT";
    char  connectstr[80];
    EXEC SQL END DECLARE SECTION;
    
    if( argc <= 1 ) return 1; // no password
    db_init( &sqlca );
    strcpy( connectstr, "DSN=SAP IQ 17 Demo;PWD=" );
    strcat( connectstr, argv[1] );
    db_string_connect( &sqlca, connectstr );
    db_register_a_callback( &sqlca, DB_CALLBACK_MESSAGE, (SQL_CALLBACK_PARM)messages );
    EXEC SQL EXECUTE IMMEDIATE :sqlstr;
    db_string_disconnect( &sqlca, "" );
    db_fini( &sqlca );
    return 0;
}
```


<!-- loioe7f221db48134b479dded29672adc406 -->

# Available Data Types for CREATE TABLE in Data Lake Relational Engine \(SAP HANA DB-Managed\)

A list of available data types when using the CREATE TABLE statement in data lake Relational Engine.



**Binary Data Type**


<table>
<tr>
<th valign="top">

Data Type



</th>
<th valign="top">

Description



</th>
</tr>
<tr>
<td valign="top">

BINARY



</td>
<td valign="top">

Binary data of a specified maximum *<length\>* in bytes.

```
BINARY [ ( <length> ) ]
```

If *<length\>* is omitted, then the default is 1 byte. The maximum size allowed is 32,767 bytes.

Use the fixed-length binary type BINARY for data in which all entries are expected to be approximately equal in length. Because entries in BINARY columns are zero-padded to the column length *<length\>*, they might require more storage space than entries in VARBINARY columns.

Use the fixed-length binary type BINARY for data in which all entries are expected to be approximately equal in length. Because entries in BINARY columns are zero-padded to the column length *<length\>*, they could require more storage space than entries in VARBINARY columns.

-   You can’t use the aggregate functions SUM, AVG, STDDEV, or VARIANCE with binary data types. The aggregate functions MIN, MAX, and COUNT support the BINARY data type.

-   HNG, WD, DATE, TIME, and DTTM indexes don’t support BINARY data.

-   Only the default index, CMP index, and TEXT index types are supported for BINARY data greater than 255 bytes in length.

-   Bit operations are supported on BINARY data that is 8 bytes or less in length.


All BINARY columns are padded with zeros to the full width of the column. Trailing zeros are truncated in all VARBINARY columns.



</td>
</tr>
<tr>
<td valign="top">

BLOB



</td>
<td valign="top">

BLOB \(binary large object\) data is supported with a length ranging from zero \(0\) to 2 PB \(petabytes\). BLOB is an alias for LONG BINARY data type. The maximum length is equal to 4 GB multiplied by the database page size \(512 KB\).



</td>
</tr>
<tr>
<td valign="top">

IMAGE



</td>
<td valign="top">

Stores binary data of arbitrary length.

IMAGE is a domain, implemented as LONG BINARY.

You can’t use the aggregate functions SUM, AVG, STDDEV, or VARIANCE with binary data types.



</td>
</tr>
<tr>
<td valign="top">

LONG BINARY



</td>
<td valign="top">

Stores binary data of arbitrary length.

The maximum length of a long binary column is 2 PB.

The maximum size in bytes is 2 GB minus 1 byte or 2147483647.

You can’t use the SUM, AVG, STDDEV, or VARIANCE aggregate functions with binary data types.



</td>
</tr>
<tr>
<td valign="top">

UNIQUEIDENTIFIER



</td>
<td valign="top">

Stores UUID \(also known as GUID\) values.

The UNIQUEIDENTIFIER data type is often used for a primary key or other unique column to hold UUID \(Universally Unique Identifier\) values that can be used to uniquely identify rows. The NEWID function generates UUID values in such a way that a value produced on one computer doesn’t match a UUID produced on another computer. UNIQUEIDENTIFIER values generated using NEWID can therefore be used as keys in a synchronization environment.

The STRTOUUID and UUIDTOSTR functions convert values between UNIQUEIDENTIFIER and string representations.

UNIQUEIDENTIFIER values are stored and returned as BINARY\(16\).

Because UNIQUEIDENTIFIER values are large, using UNSIGNED BIGINT or UNSIGNED INT identity columns instead of UNIQUEIDENTIFIER is more efficient when you don’t need cross-database unique identifiers.

You can’t use the aggregate functions SUM, AVG, STDDEV, or VARIANCE with the UNIQUIEIDENTIFIER data type.

The following statement updates the table MYTAB and sets the value of the column uid\_col to a unique identifier generated by the NEWID function, if the current value of the column is NULL:

```
UPDATE MYTAB
    SET uid_col = NEWID()
      WHERE uid_col IS NULL;
```

1.  If you execute the following statement, then the unique identifier is returned as a BINARY\(16\):

    ```
    SELECT NEWID();
    ```

2.  For example, the value could be 0xd3749fe09cf446e399913bc6434f1f08. You can convert this string into a readable format using the UUIDTOSTR function.




</td>
</tr>
<tr>
<td valign="top">

VARBINARY



</td>
<td valign="top">

Binary data up to a specified *<max-length\>* in bytes.

```
VARBINARY [ ( <length> ) ]
```

If *<length\>* is omitted, then the default is 1 byte. The maximum size allowed is \(32 K – 1\) bytes. Use the variable-length binary type VARBINARY for data that is expected to vary greatly in length.

Use the variable-length binary type VARBINARY for data that is expected to vary greatly in length.

-   You can’t use the aggregate functions SUM, AVG, STDDEV, or VARIANCE with binary data types. The aggregate functions MIN, MAX, and COUNT support the VARBINARY data type.

-   HNG, WD, DATE, TIME, and DTTM indexes don’t support VARBINARY data.

-   Only the default index, CMP index, and TEXT index types are supported for VARBINARY data greater than 255 bytes in length.

-   Bit operations are supported on VARBINARY data that is 8 bytes or less in length.


All BINARY columns are padded with zeros to the full width of the column. Trailing zeros are truncated in all VARBINARY columns.



</td>
</tr>
</table>

**BIT Data Type**


<table>
<tr>
<th valign="top">

Data Type



</th>
<th valign="top">

Description



</th>
</tr>
<tr>
<td valign="top">

BIT



</td>
<td valign="top">

Accepts values of 1, 0, or NULL. Also accepts BOOLEAN tokens TRUE, FALSE, or UNKNOWN, where UNKNOWN is a synonym of NULL.

The default nullability is NOT NULL.

Inserting any nonzero value into a BIT column stores a 1 in the column.

When converting a string to a BIT, leading and trailing spaces are removed. If the leading character is +, it's ignored. If the leading character is -, the remaining digits are interpreted as a negative number. Leading 0 characters are skipped, and the remaining characters are converted to an integer value. An error is returned if the value isn't 0 or 1.

Only the default index type is supported for BIT data.



</td>
</tr>
<tr>
<td valign="top">

BOOLEAN



</td>
<td valign="top">

BOOLEAN is a synonym of BIT, not a native data type.

The underlying data type is BIT and the default nullability is NULL.



</td>
</tr>
</table>

**BOOLEAN Data Type**


<table>
<tr>
<th valign="top">

Data Type



</th>
<th valign="top">

Description



</th>
</tr>
<tr>
<td valign="top">

BOOLEAN



</td>
<td valign="top">

Boolean values are TRUE, FALSE, and UNKNOWN, where UNKNOWN is a synonym of NULL.

If a remote source does not support the BOOLEAN data type, it returns 1 for TRUE and 0 for FALSE.



</td>
</tr>
</table>

**Character Data Types**


<table>
<tr>
<th valign="top">

Data Type



</th>
<th valign="top">

Description



</th>
</tr>
<tr>
<td valign="top">

CLOB



</td>
<td valign="top">

Supports character large object \(CLOB\) data with a length ranging from zero \(0\) to 512 TB \(terabytes\).

The maximum length is equal to 4 GB multiplied by the database page size \(512 KB\).



</td>
</tr>
<tr>
<td valign="top">

LONG VARCHAR



</td>
<td valign="top">

Stores character data of arbitrary length. The maximum size in bytes is 2 GB minus 1 \(2<sup>31</sup> - 1\) or 2 147 483 647.

Multibyte characters can be stored as LONG VARCHAR, but the length is in bytes, not characters.

VARCHARhas no blank padding is added to the storage of these strings.



</td>
</tr>
<tr>
<td valign="top">

TEXT



</td>
<td valign="top">

Stores character data of arbitrary length. TEXT is a domain, implemented as a LONG VARCHAR.



</td>
</tr>
<tr>
<td valign="top">

VARCHAR



</td>
<td valign="top">

Stores arbitrary length character data.

```
VARCHAR [ ( <max-length> [ BYTE | CHAR | CHARACTER ] ) ]
```

 *<max-length\>*
 :   If CHAR or CHARACTER \(byte-length semantics\) is not specified as part of the length, then the length is in bytes and must be in the range of 1 to 32767\(32 KB – 1\). If BYTE is specified,*<max-length\>* must be specified. If only VARCHAR is specified, then *<max-length\>* is 1 with byte-length semantic.

    If CHAR or CHARACTER \(character-length semantics\) is specified as part of the length, then the length is in characters, and *<max-length\>* must be specified, to a maximum of 5000.

 VARCHARhas no blank padding added to the storage of these strings.

All index types, except DATE, TIME, and DATETIME/TIMESTAMP are supported for VARCHAR data to a maximum of to 255 bytes in length. For VARCHAR using character-length semantic, the maximum byte length depends on the number of bytes used per character. The limit becomes 255 divided by the number of bytes per character.



</td>
</tr>
</table>

**Data and Time Data Types**


<table>
<tr>
<th valign="top">

Data Type



</th>
<th valign="top">

Description



</th>
</tr>
<tr>
<td valign="top">

DATE



</td>
<td valign="top">

A calendar date, such as a year, month, and day. The year can be from 0001 to 9999. The day must be a nonzero value, so that the minimum date is 0001-01-01. A DATE value requires 4 bytes of storage.



</td>
</tr>
<tr>
<td valign="top">

DATETIME



</td>
<td valign="top">

A domain, implemented as TIMESTAMP. The fraction is stored to 6 decimal places \(not 7\). A DATETIME value requires 8 bytes of storage.



</td>
</tr>
<tr>
<td valign="top">

DATETIMEX



</td>
<td valign="top">

Point in time, containing year, month, day, hour, minute, second, and fraction of a second. The fraction is stored to 7 decimal places, regardless of the TIMESTAMP\_COLUMNS\_AS\_DATETIMEX database option. The day must be a nonzero value. A DATETIMEX value requires 8 bytes of storage.



</td>
</tr>
<tr>
<td valign="top">

SMALLDATETIME



</td>
<td valign="top">

A domain, implemented as TIMESTAMP. A SMALLDATETIME value requires 8 bytes of storage.



</td>
</tr>
<tr>
<td valign="top">

TIME



</td>
<td valign="top">

Time of day, containing hour, minute, second, and fraction of a second. The fraction is stored to 6 decimal places. A TIME value requires 8 bytes of storage. \(ODBC standards restrict TIME data type to an accuracy of seconds. For this reason, do not use TIME data types in WHERE clause comparisons that rely on a higher accuracy than seconds.\)



</td>
</tr>
<tr>
<td valign="top">

TIMESTAMP



</td>
<td valign="top">

Point in time, containing year, month, day, hour, minute, second, and fraction of a second. The fraction is stored to 6 or 7 decimal precision, depending on the value of the TIMESTAMP\_COLUMNS\_AS\_DATETIMEX database option. For more information, see [Decimal Precision of the TIMESTAMP Data Type in Data Lake Relational Engine \(SAP HANA DB-Managed\)](../020-sql-data-types/decimal-precision-of-the-timestamp-data-type-in-data-lake-relational-engine-sap-hana-db-m-5cbca14.md). The day must be a nonzero value. A TIMESTAMP value requires 8 bytes of storage.



</td>
</tr>
</table>

**Numeric Data Type**


<table>
<tr>
<th valign="top" rowspan="1">

Data Type



</th>
<th valign="top" rowspan="1">

Description



</th>
</tr>
<tr>
<td valign="top" rowspan="1">

BIGINT



</td>
<td valign="top" rowspan="1">

A signed 64-bit integer, requiring 8 bytes of storage.

```
[ UNSIGNED ] BIGINT
```

You can specify integers as UNSIGNED. By default the data type is signed. Its range is between -9223372036854775808 and 9223372036854775807 \(signed\) or from 0 to 18446744073709551615 \(unsigned\).



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

DECIMAL



</td>
<td valign="top" rowspan="1">

A signed decimal number with *<precision\>* total digits and with *<scale\>* of the digits after the decimal point.

```
DECIMAL [ ( <precision> [ , <scale> ] ) ]
```

*<precision\>* can equal 1 to 126, inclusive, specifying the number of digits in the expression. *<scale\>* can equal 0 up to precision value, specifying the number of digits after the decimal point. The defaults are scale = 38 and precision = 126. Results are calculated based on the actual data type of the column to ensure accuracy, but you can set the maximum scale of the result returned to the application using the MAX\_CLIENT\_NUMERIC\_SCALE option.



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

DOUBLE



</td>
<td valign="top" rowspan="1">

A signed double-precision floating-point number stored in 8 bytes. The range of absolute, nonzero values is between 2.2250738585072014e-308 and 1.797693134862315708e+308. Values held as DOUBLE are accurate to 15 significant digits, but might be subject to rounding errors beyond the 15th digit.

The DOUBLE data type is an approximate numeric data type; it is subject to rounding errors after arithmetic operations.



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

FLOAT



</td>
<td valign="top" rowspan="1">

Stores a floating-point number, which can be single or double precision.

```
FLOAT [ ( <precision> ) ]
```

If *<precision\>* supplied, then the FLOAT data type is the same as the REAL or DOUBLE data type, depending on the value of the precision. The cutoff between REAL and DOUBLE is platform-dependent, and it is the number of bits used in the mantissa of single-precision floating point number on the platform. If not supplied, then the FLOAT data type is the same as the REAL data type.

When a column is created using the FLOAT data type, columns on all platforms are guaranteed to hold the values to at least the specified minimum precision. In contrast, REAL and DOUBLE do not guarantee a platform-independent minimum precision.

The FLOAT data type is an approximate numeric data type; it is subject to rounding errors after arithmetic operations.



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

INT or INTEGER



</td>
<td valign="top" rowspan="1">

Stores integers that require 4 bytes of storage.

```
[ UNSIGNED ] INT[EGER]
```

A signed 32-bit integer with a range of values between -2147483648 and 2147483647 requiring 4 bytes of storage.

The INTEGER data type is an exact numeric data type; its accuracy is preserved after arithmetic operations.

You can specify integers as UNSIGNED; by default the data type is signed. The range of values for an unsigned integer is between 0 and 4294967295.



</td>
</tr>
<tr>
<td valign="top">

MONEY



</td>
<td valign="top">

Stores monetary data. MONEY is a domain, implemented as NUMERIC\(19,4\).



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

NUMERIC



</td>
<td valign="top" rowspan="1">

Same as DECIMAL.

```
NUMERIC [ ( <precision> [ , <scale> ] ) ]
```



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

REAL



</td>
<td valign="top" rowspan="1">

A signed single-precision floating-point number stored in 4 bytes. The range of absolute, nonzero values is 1.175494351e-38 to 3.402823466e+38. Values held as REAL are accurate to 6 significant digits, but might be subject to rounding errors beyond the sixth digit.

The REAL data type is an approximate numeric data type; it is subject to rounding errors after arithmetic operations.



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

SMALLINT



</td>
<td valign="top" rowspan="1">

A signed 16-bit integer with a range between -32768 and 32767, requiring 2 bytes of storage.

The SMALLINT data type is an exact numeric data type; its accuracy is preserved after arithmetic operations.



</td>
</tr>
<tr>
<td valign="top">

SMALLMONEY



</td>
<td valign="top">

Stores monetary data that is less than one million currency units. SMALLMONEY is a domain, implemented as NUMERIC\(10,4\).



</td>
</tr>
<tr>
<td valign="top" rowspan="1">

TINYINT



</td>
<td valign="top" rowspan="1">

An unsigned 8-bit integer with a range between 0 and 255, requiring 1 byte of storage.

The TINYINT data type is an exact numeric data type; its accuracy is preserved after arithmetic operations.



</td>
</tr>
</table>

